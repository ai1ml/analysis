# =========================
# EC2 OnDemand — filters + tabs wired to your ec2_ops_setup.py views
# =========================
import streamlit as st

def _q(x: str) -> str:
    return str(x).replace("'", "''")

def _ec2_distinct(col, src="ec2_od_norm"):
    try:
        rows = con.execute(f"SELECT DISTINCT {col} FROM {src} WHERE {col} IS NOT NULL ORDER BY 1").fetchall()
        return [r[0] for r in rows if r[0] is not None]
    except Exception:
        return []

def _view_exists(name: str) -> bool:
    try:
        con.execute(f"SELECT * FROM {name} LIMIT 0")
        return True
    except Exception:
        return False

def pick_view(candidates):
    for v in candidates:
        if _view_exists(v):
            return v
    return None

# ---------- Sidebar filters (aligned with your CSV columns) ----------
st.sidebar.subheader("Filters — EC2 OnDemand")

# Business Area
ba_opts = ["(all)"] + _ec2_distinct("business_area")
sel_ba = st.sidebar.selectbox("Business Area", ba_opts, index=0, key="ec2_ba")

# Purchase option (OnDemand / Spot)
po_opts = ["(all)"] + [p for p in _ec2_distinct("purchase_option") if p]
sel_po = st.sidebar.selectbox("Purchase option", po_opts, index=0, key="ec2_po")

# Family (derived if not present in the view)
fam_opts = ["(all)"]
try:
    fam_opts = ["(all)"] + [f for f in _ec2_distinct("family") if f]
except Exception:
    pass
sel_family = st.sidebar.selectbox("Instance family", fam_opts, index=0, key="ec2_family")

# CPU & Hours & Min Cost sliders (robust to column names)
data_max_cpu = con.execute("""
    SELECT COALESCE(MAX(COALESCE(avg_cpu_14d, fourteendayaveragecpuutilization)), 0) FROM ec2_od_norm
""").fetchone()[0] or 0
data_max_hours = con.execute("""
    SELECT COALESCE(MAX(COALESCE(hours, usage_quantity_hours, usage_quantity)), 0) FROM ec2_od_norm
""").fetchone()[0] or 0
data_max_cost = con.execute("""
    SELECT COALESCE(MAX(COALESCE(cost_usd, total_cost)), 0) FROM ec2_od_norm
""").fetchone()[0] or 0

cpu_low, cpu_high   = st.sidebar.slider("CPU (avg 14d, %)", 0, 100, (0, min(100, int(data_max_cpu or 100))), key="ec2_cpu")
hours_low, hours_high = st.sidebar.slider("Hours in month", 0, max(720, int(data_max_hours or 0)),
                                         (0, max(160, min(720, int(data_max_hours or 720)))), key="ec2_hours")
min_cost = st.sidebar.slider("Min monthly cost (USD)", 0.0, float(max(1000.0, data_max_cost or 0.0)),
                             0.0, step=5.0, key="ec2_min_cost")

acct_query = st.sidebar.text_input("Linked Account contains (optional)", value="", key="ec2_acct_search")

# ---------- WHERE builder that only uses columns present in the target view ----------
def ec2_where_for_view(view_name: str, base: str = "1=1") -> str:
    cols = set(con.execute(f"SELECT * FROM {view_name} LIMIT 0").fetchdf().columns)
    wc = [base]

    if "business_area" in cols and sel_ba != "(all)":
        wc.append(f"business_area = '{_q(sel_ba)}'")

    if "purchase_option" in cols and sel_po != "(all)":
        wc.append(f"LOWER(purchase_option) = LOWER('{_q(sel_po)}')")

    # family — if not present, we’ll filter by regex on instance_type when available
    if sel_family != "(all)":
        if "family" in cols:
            wc.append(f"family = '{_q(sel_family)}'")
        elif "current_instance_type" in cols:
            wc.append(f"REGEXP_EXTRACT(current_instance_type, '^([a-z0-9]+)\\..+$', 1) = '{_q(sel_family)}'")

    # CPU
    if "avg_cpu_14d" in cols:
        wc.append(f"avg_cpu_14d BETWEEN {int(cpu_low)} AND {int(cpu_high)}")
    elif "fourteendayaveragecpuutilization" in cols:
        wc.append(f"fourteendayaveragecpuutilization BETWEEN {int(cpu_low)} AND {int(cpu_high)}")

    # Hours
    if "hours" in cols:
        wc.append(f"hours BETWEEN {int(hours_low)} AND {int(hours_high)}")
    elif "usage_quantity_hours" in cols:
        wc.append(f"usage_quantity_hours BETWEEN {int(hours_low)} AND {int(hours_high)}")
    elif "usage_quantity" in cols:
        wc.append(f"usage_quantity BETWEEN {int(hours_low)} AND {int(hours_high)}")

    # Cost
    if "cost_usd" in cols:
        wc.append(f"cost_usd >= {float(min_cost)}")
    elif "total_cost" in cols:
        wc.append(f"total_cost >= {float(min_cost)}")

    # Account search
    if acct_query:
        for col in ("linked_account_id", "account_id"):
            if col in cols:
                wc.append(f"CAST({col} AS VARCHAR) ILIKE '%{_q(acct_query)}%'")
                break

    return " AND ".join(wc)

def _show_q(q: str, title: str = None):
    if title:
        st.subheader(title, divider=False)
    st.caption(q)
    st.dataframe(con.execute(q).fetchdf(), hide_index=True, use_container_width=True)

# ---------- Tabs (wired to actual/fallback view names) ----------
tabA, tabB, tabC, tabD = st.tabs([
    "Overview", "Savings Opportunities", "Utilization", "Recommended Actions"
])

# 1) Overview
with tabA:
    c1, c2 = st.columns(2)
    # BA × Region (fallback to BA or Region)
    v = pick_view(["ec2_od_by_ba_region", "ec2_od_by_ba", "ec2_od_by_region"])
    if v:
        q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY COALESCE(total_cost_usd, total_cost) DESC"
        label = "By BA × Region" if v == "ec2_od_by_ba_region" else ("By Business Area" if v == "ec2_od_by_ba" else "By Region")
        _show_q(q, title=label)
    # Family rollup (if you created one)
    with c2:
        v2 = pick_view(["ec2_od_by_family", "ec2_od_family_rollup"])
        if v2:
            q2 = f"SELECT * FROM {v2} WHERE {ec2_where_for_view(v2)} ORDER BY COALESCE(total_cost_usd, total_cost) DESC"
            _show_q(q2, title="By Instance Family")

# 2) Savings Opportunities
with tabB:
    # Off-hours candidates (non-prod 24×7)
    v = pick_view(["ec2_od_offhours_candidates", "ec2_ops_offhours_candidates"])
    if v:
        q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY est_monthly_savings_usd DESC NULLS LAST"
        _show_q(q, title="Off-hours Candidates")

    # Spot candidates (workloads eligible to move to Spot)
    v = pick_view(["ec2_od_spot_candidates", "ec2_ops_spot_candidates"])
    if v:
        q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY est_monthly_savings_usd DESC NULLS LAST"
        _show_q(q, title="Spot Candidates")

    # Rightsize candidates (next smaller)
    v = pick_view(["ec2_od_rightsize_candidates", "ec2_ops_rightsize_candidates"])
    if v:
        q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY est_monthly_savings_usd DESC NULLS LAST"
        _show_q(q, title="Rightsize Candidates")

# 3) Utilization
with tabC:
    c1, c2 = st.columns(2)
    with c1:
        v = pick_view(["ec2_od_low_utilization", "ec2_ops_low_utilization"])
        if v:
            q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY COALESCE(cost_usd, total_cost) DESC"
            _show_q(q, title="Low Utilization")
    with c2:
        v = pick_view(["ec2_od_high_utilization", "ec2_ops_high_utilization"])
        if v:
            q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY COALESCE(cost_usd, total_cost) DESC"
            _show_q(q, title="High Utilization")

# 4) Recommended Actions (ranked)
with tabD:
    v = pick_view(["ec2_od_actions_ranked", "ec2_ops_actions_ranked"])
    if v:
        q = f"SELECT * FROM {v} WHERE {ec2_where_for_view(v)} ORDER BY est_monthly_savings_usd DESC NULLS LAST, COALESCE(cost_usd, total_cost) DESC NULLS LAST"
        _show_q(q, title="Recommended Actions (ranked)")
    else:
        st.info("Action ranking view not found. If you want this tab, create a view named `ec2_od_actions_ranked`.")




CREATE OR REPLACE VIEW ec2_od_by_ba_region AS
SELECT
  business_area,
  region,
  COUNT(*) AS instance_count,
  SUM(COALESCE(cost_usd, total_cost)) AS total_cost_usd
FROM ec2_od_norm
GROUP BY business_area, region;
